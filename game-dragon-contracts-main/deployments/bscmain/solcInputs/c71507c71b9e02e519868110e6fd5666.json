{
  "language": "Solidity",
  "sources": {
    "contracts/PreSaleDragonEgg.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n    address public owner;\n\n    /**\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n     * account.\n     */\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\n     * @param newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (newOwner != address(0)) {\n            owner = newOwner;\n        }\n    }\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n    event Pause();\n    event Unpause();\n\n    bool public paused = false;\n\n    /**\n     * @dev modifier to allow actions only when the contract IS paused\n     */\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /**\n     * @dev modifier to allow actions only when the contract IS NOT paused\n     */\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    /**\n     * @dev called by the owner to pause, triggers stopped state\n     */\n    function pause() public onlyOwner whenNotPaused returns (bool) {\n        paused = true;\n        emit Pause();\n        return true;\n    }\n\n    /**\n     * @dev called by the owner to unpause, returns to normal state\n     */\n    function unpause() public onlyOwner whenPaused returns (bool) {\n        paused = false;\n        emit Unpause();\n        return true;\n    }\n}\n\nstruct Attribute {\n    uint256 health;\n    uint256 attack;\n    uint256 defense;\n    uint256 speed;\n    uint256 lifeForce;\n}\n\nstruct Skill {\n    uint256 horn;\n    uint256 ear;\n    uint256 wing;\n    uint256 tail;\n    uint256 talent;\n}\n\ninterface IDragonToken {\n    // create dragon egg\n    function createDragonEggs(\n        uint8 _job,\n        uint256 _id,\n        address _owner,\n        uint256 _timestamp,\n        bytes memory _sign\n    ) external returns (bool);\n\n    // hatch dragon egg\n    function hatchDragonEggs(\n        uint256 _id,\n        uint256 _geneDomi,\n        uint256 _geneRece,\n        uint256 _matronId,\n        uint256 _sireId,\n        uint16 _stage,\n        Attribute memory _attr,\n        Skill memory _skill,\n        string memory _uri,\n        uint256 _timestamp,\n        bytes memory _sign\n    ) external returns (bool);\n}\n\n/**\n * @title dragon egg presale contract\n * @dev dragon egg buy and grow up.\n */\ncontract PreSaleDragonEgg is Pausable {\n    struct PreSale {\n        // job 1-5 Water Fire Rock Storm Thunder\n        uint8 job;\n        uint256 price;\n        uint256 id;\n        string email;\n    }\n\n    // dragonToken\n    IDragonToken public dragonToken;\n\n    // start time\n    uint256 public start_time;\n    // presale total\n    uint256 public total_buy;\n    // total\n    uint256 public total = 1000;\n    // recipient address\n    address payable public recipient;\n    // sale price todo\n    uint256 public prices = 0.1 ether;\n    // sale job\n    uint256 public job = 2;\n\n    event Buy(\n        address indexed account,\n        uint8 job,\n        uint256 price,\n        uint256 id,\n        string email\n    );\n\n    // account is buyed\n    mapping(address => bool) private _buyed;\n    // email is buyed\n    mapping(bytes32 => bool) private _emails;\n    // account => presale data\n    mapping(address => PreSale) private _accounts;\n    // presale tokenId => account\n    mapping(uint256 => address) private _ids;\n\n    constructor(address _dragon, address _recipient) {\n        // 2021.10.15（16:00:00 UTC+4）todo\n        start_time = block.timestamp;\n        dragonToken = IDragonToken(_dragon);\n        recipient = payable(_recipient);\n    }\n\n    modifier is_start() {\n        require(block.timestamp > start_time, \"presale is not start\");\n        _;\n    }\n\n    modifier is_end() {\n        require(total_buy <= total, \"presale is end\");\n        _;\n    }\n\n    modifier id_exist(uint256 _id) {\n        require(_ids[_id] == address(0), \"id is exist\");\n        _;\n    }\n\n    modifier is_buyed() {\n        require(_buyed[msg.sender] == false, \"your is buyed\");\n        _;\n    }\n\n    modifier has_email(string memory _email) {\n        bytes32 key = keccak256(abi.encodePacked(_email));\n        require(_emails[key] == false, \"email is exist\");\n        _;\n    }\n\n    function getId(uint256 _id) public view returns (address) {\n        return _ids[_id];\n    }\n\n    function buy(\n        uint8 _job,\n        uint256 _id,\n        string calldata _email,\n        uint256 _timestamp,\n        bytes memory _sign\n    )\n        external\n        payable\n        whenNotPaused\n        is_start\n        is_end\n        is_buyed\n        has_email(_email)\n        id_exist(_id)\n        returns (bool)\n    {\n        uint256 _price = msg.value;\n        require(_job >= 1 && _job <= 5 && _job == job, \"invalid job\");\n        require(_price > 0, \"invalid price\");\n        require(_id > 0, \"invalid tokenId\");\n        bytes32 _mailKey = keccak256(abi.encodePacked(_email));\n        require(_mailKey != keccak256(abi.encodePacked(\"\")), \"invalid email\");\n        require(_price >= prices, \"invalid price\");\n        total_buy += 1;\n        _accounts[msg.sender] = PreSale(_job, _price, _id, _email);\n        _buyed[msg.sender] = true;\n        _emails[_mailKey] = true;\n        _ids[_id] = msg.sender;\n        emit Buy(msg.sender, _job, _price, _id, _email);\n        recipient.transfer(_price);\n        // dragon token\n        require(\n            dragonToken.createDragonEggs(\n                _job,\n                _id,\n                msg.sender,\n                _timestamp,\n                _sign\n            )\n        );\n        return true;\n    }\n\n    //  hatch dragon egg\n    function hatchDragonEgg(\n        uint256 _id,\n        uint256 _geneDomi,\n        uint256 _geneRece,\n        uint256 _matronId,\n        uint256 _sireId,\n        uint16 _stage,\n        Attribute memory _attr,\n        Skill memory _skill,\n        string memory _uri,\n        uint256 _timestamp,\n        bytes memory _sign\n    ) external returns (bool) {\n        require(_ids[_id] != address(0), \"id is not exist\");\n        require(\n            dragonToken.hatchDragonEggs(\n                _id,\n                _geneDomi,\n                _geneRece,\n                _matronId,\n                _sireId,\n                _stage,\n                _attr,\n                _skill,\n                _uri,\n                _timestamp,\n                _sign\n            )\n        );\n        return true;\n    }\n\n    function result(address account) public view returns (bool) {\n        return _buyed[account];\n    }\n\n    function getPresale(address account)\n        public\n        view\n        returns (\n            uint8,\n            uint256,\n            uint256,\n            string memory\n        )\n    {\n        PreSale memory _presale = _accounts[account];\n        return (_presale.job, _presale.price, _presale.id, _presale.email);\n    }\n\n    function setRecipient(address _account) external onlyOwner {\n        require(_account != address(0), \"account address is zero\");\n        recipient = payable(_account);\n    }\n\n    function setPrice(uint256 _price) external onlyOwner {\n        require(_price > 0, \"invalid price\");\n        prices = _price;\n    }\n\n    function setTotal(uint256 _total) external onlyOwner {\n        require(_total > 0, \"invalid total\");\n        total = _total;\n    }\n\n    function setJob(uint256 _job) external onlyOwner {\n        require(_job > 0, \"invalid job\");\n        job = _job;\n    }\n\n    function setStart(uint256 _start) external onlyOwner returns (bool) {\n        require(_start >= block.timestamp, \"invalid start\");\n        start_time = _start;\n        return true;\n    }\n\n    function setDragonToken(address _token) external onlyOwner returns (bool) {\n        require(_token != address(0), \"invalid token address\");\n        dragonToken = IDragonToken(_token);\n        return true;\n    }\n\n    receive() external payable {}\n\n    function destroy() external onlyOwner {\n        selfdestruct(payable(msg.sender));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}